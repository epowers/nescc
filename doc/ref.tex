% Not in ref manual (implementation restriction rather than language feature):
%   no initialisers on module variables (future support)
%   (but vars w/ attribute C are not module vars)

\documentclass[11pt,letterpaper]{article}

\usepackage{fullpage}
\usepackage{xspace}
\usepackage{hyperref}

\newcommand{\kw}[1]{{\tt #1}}
\newcommand{\code}[1]{{\tt #1}}
\newcommand{\file}[1]{{\tt #1}}
\newcommand{\nesc}{nesC\xspace}
\newcommand{\tinyos}{TinyOS\xspace}
\newcommand{\opt}{$_{\mbox{opt}}$\xspace}
\newcommand{\FSE}{\mathcal{F}}
\newcommand{\connect}{\mathcal{C}}

\parskip 0.15cm
\parindent 0cm

\newcommand{\grammarshift}{\vspace*{-.7cm}}
\newcommand{\grammarindent}{\hspace*{2cm}\= \\ \kill}

\begin{document}

\title{\nesc 1.1 Language Reference Manual}
\author{David Gay, Philip Levis, David Culler, Eric Brewer}
\date{May 2003}

\maketitle

\section{Introduction}

\nesc is an extension to C~\cite{kandr} designed to embody the structuring
concepts and execution model of \tinyos~\cite{tinyos}. \tinyos is an
event-driven operating system designed for sensor network nodes that have
very limited resources (e.g., 8K bytes of program memory, 512 bytes of
RAM). \tinyos has been reimplemented in \nesc. This manual describes v1.1 of
\nesc, changes from v1.0 are summarised in Section~\ref{sec:changes}.

The basic concepts behind \nesc are:
\begin{itemize}
\item Separation of construction and composition: programs are built out of
\emph{components}, which are assembled (``wired'') to form whole
programs. Components define two scopes, one for their specification
(containing the names of their \emph{interfaces}) and one for
their implementation. Components have internal concurrency in the form of
\emph{tasks}. Threads of control may pass into a component through its
interfaces. These threads are rooted either in a task or a hardware
interrupt.

\item Specification of component behaviour in terms of set of
\emph{interfaces}. Interfaces may be provided or used by the component. The
provided interfaces are intended to represent the functionality that the
component provides to its user, the used interfaces represent the
functionality the component needs to perform its job.

\item Interfaces are bidirectional: they specify a set of functions to be
implemented by the interface's provider (\emph{commands}) and a set to be
implemented by the interface's user (\emph{events}). This allows a single
interface to represent a complex interaction between components (e.g.,
registration of interest in some event, followed by a callback when
that event happens). This is critical because all lengthy commands in
\tinyos (e.g. send packet) are non-blocking; their completion is
signaled through an event (send done). By specifying interfaces, a
component cannot call the \code{send} command unless it provides an
implementation of the \code{sendDone} event.

Typically commands call downwards, i.e., from application components to
those closer to the hardware, while events call upwards. Certain primitive
events are bound to hardware interrupts (the nature of this binding is
system-dependent, so is not described further in this reference manual).

\item Components are statically linked to each other via their interfaces.
This increases runtime efficiency, encourages robust design, and allows for
better static analysis of programs.

\item \nesc is designed under the expectation that code will be generated
by whole-program compilers. This allows for better code generation and
analysis. An example of this is nesC's compile-time data race detector.

\item The concurrency model of \nesc is based on run-to-completion tasks,
and interrupt handlers which may interrupt tasks and each other. The \nesc
compiler signals the potential data races caused by the interrupt handlers.
\end{itemize}

This document is a reference manual for \nesc rather than a tutorial. The
\tinyos tutorial\footnote{Available with the \tinyos distribution at
http://webs.cs.berkeley.edu} presents a gentler introduction to \nesc.

The rest of this document is structured as follows:
Section~\ref{sec:notation} presents the notation used in the reference
manual. Section~\ref{sec:changes} summarises the new features in \nesc
1.1. Sections~\ref{sec:interface},~\ref{sec:component},~\ref{sec:module},
and~\ref{sec:configuration} present \nesc interfaces and
components. Section~\ref{sec:concurrency} presents \nesc's concurrency
model and data-race detection. Section~\ref{sec:app} explains how C files,
\nesc interfaces and components are assembled into an
application. Section~\ref{sec:misc} covers the remaining miscellaneous
features of \nesc. Finally, Appendix~\ref{sec:grammar} fully defines
\nesc's grammar (as an extension to the C grammar from Appendix~A of
Kernighan and Ritchie (K\&R) ~\cite[pp234--239]{kandr}), and
Appendix~\ref{sec:glossary} is a glossary of the terms used in this
reference manual.

\section{Notation}
\label{sec:notation}

The \texttt{typewriter} font is used for \nesc code and for
filenames. Single symbols in italics, with optional subscripts, are used to
refer to \nesc entities, e.g., ``component $K$'' or ``value $v$''.

The grammar of \nesc is an extension the ANSI C grammar. We chose to base
our presentation on the ANSI C grammar from Appendix~A of Kernighan and
Ritchie (K\&R) ~\cite[pp234--239]{kandr}. We will not repeat productions
from that grammar here. Words in \emph{italics} are non-terminals and
non-literal terminals, \kw{typewriter} words and symbols are literal
terminals. The subscript \emph{opt} indicates optional terminals or
non-terminals. In some cases, we change some ANSI C grammar rules. We
indicate this as follows: \emph{also} indicates additional productions for
existing non-terminals, \emph{replaced by} indicates replacement of an
existing non-terminal. 

Explanations of \nesc constructs are presented along with the corresponding
grammar fragments. In these fragments, we sometimes use \ldots to represent
elided productions (irrelevant to the construct at
hand). Appendix~\ref{sec:grammar} presents the full \nesc grammar.

Several examples use the \code{uint8\_t} and \code{uint16\_t} types from
the C99 standard \file{inttypes.h} file.

\section{Changes}
\label{sec:changes}

The changes from \nesc 1.0 to 1.1 are:
\begin{enumerate}
\item \kw{atomic} statements. These simplify implementation of concurrent
data structures, and are understood by the new compile-time data-race
detector.

\item Compile-time data-race detection gives warnings for variables that
are potentially accessed concurrently by two interrupt handlers, or an
interrupt handler and a task.

\item Commands and events which can safely be executed by interrupt
handlers must be explicitly marked with the \kw{async} storage class
specifier.

\item The results of calls to commands or events with ``fan-out'' are
automatically combined by new type-specific combiner functions.

\item \kw{uniqueCount} is a new ``constant function'' which counts
uses of \kw{unique}.

\item The \kw{NESC} preprocessor symbol indicates the language version. It
is 110 for \nesc 1.1.
 
\end{enumerate}

\section{Scopes and Name Spaces in \nesc}
\label{sec:scoping}

\nesc includes the standard C name spaces: \emph{object}, which includes
variables, functions, typedefs, and enum-constants; \emph{label} for
\kw{goto} labels; \emph{tag} for \kw{struct}, \kw{union}, \kw{enum} tags.
It adds an additional \emph{component} name space for component and
interface definitions. For simplicity, we assume that each scope contains
all four name spaces, though language restrictions mean that many of these
name spaces are empty (e.g., all component and interface definitions are
global, so the \emph{component} name space is empty in all but the global
scope).

\nesc follows the standard C scoping rules, with the following
additions:
\begin{itemize}
\item Each interface definition introduces two scopes. The \emph{interface
parameter scope} is nested in the global scope and contains the parameters
of generic interface definitions. The \emph{interface scope} is nested in
the interface parameter scope and contains the interface's commands and
events.

\item Each component definition introduces three new scopes. The
\emph{component parameter scope} is nested in the global scope and contains
the parameters of generic component definitions. The \emph{specification
scope} is nested in the component parameter scope and contains the
component's specification elements. 

The \emph{implementation scope} is nested in the specification scope.  For
configurations, the implementation scope contains the names by which this
component refers to its included components
(Section~\ref{sec:config-components}). For modules, the implementation
scope holds the tasks, C declarations and definitions that form the
module's body. These declarations, etc may introduce their own nested
scopes within the implementation scope, following the usual C scoping
rules.
\end{itemize}
As usual in C, scopes must not have multiple definitions of the same
name within the same name space.

\section{Interface and Component Specification}
\label{sec:interface}

A \nesc \emph{interface definition} specifies a bi-directional interaction
between two components, known as the \emph{provider} and
\emph{user}. Interactions via interfaces are specified by two sets of
functions: \emph{commands} are function calls from the user to the provider
component, \emph{events} are function calls from the provider to the user
component. In many cases, the provider component is providing some service
(e.g., sending messages over the radio) and commands represent requests,
events responses.

An interface definition has a unique name, optional C type parameters, and
contains declarations for its command and event functions. An interface
definition with type parameters is called a \emph{generic interface
definition}.

An \emph{interface type} is a reference to an interface definition and, if
the referenced definition is generic, corresponding type
arguments. Components can only be connected via two interfaces with the
same type.

A component's \emph{specification} is the set of interfaces that it
provides and uses. Component specifications can also contain \emph{bare}
commands and events (i.e., not contained in an interface), for clarity of
exposion we defer discussion of these to Section~\ref{sec:bare}. Each
provided or used interface has a name and an interface type.

For instance, the following source code
\begin{quote} \begin{verbatim}
interface SendMsg { // send a radio message
  command result_t send(uint16_t address, uint8_t length, TOS_MsgPtr msg);
  event result_t sendDone(TOS_MsgPtr msg, result_t success);
}

interface Init<t> { // a generic interface definition
  command void doit(t x);
}

module Simple {
  provides interface Init<int> as MyInit;
  uses interface SendMsg as MyMessage;
} ...
\end{verbatim} \end{quote}
shows two interface definitions, \code{SendMsg} and \code{Init}, and the
specification of the \code{Simple} component. The specification of
\code{Simple} has two elements: \code{MyInit}, a provided interface of type
\code{Init<int>} and \code{MyMessage} a used interface of type
\code{SendMsg}. \code{Simple} must implement the \code{MyInit.doit} command
and the \code{MyMessage.sendDone} event. It can call the
\code{MyMessage.send} command.

The rest of this section covers interface definitions, interface types and
component specifications in detail.  The sections on component
implementations (Sections~\ref{sec:module} and~\ref{sec:configuration})
explain how commands and events are called and implemented, and how
components are linked together through their interfaces.

\subsection{Interface Definitions}

Interface definitions have the following syntax:
\begin{quote} \grammarshift
\em \begin{tabbing}
\grammarindent
interface-definition:\\
\>	\kw{interface} identifier type-parameters\opt\kw{\{} declaration-list \kw{\}}
\end{tabbing}
\end{quote}
Interface definitions have a name (\emph{identifier}) with global
scope. This name belongs to the component name space
(Section~\ref{sec:scoping}), so interface definitions must have a name
distinct from other interface definitions and from components, however they
do not conflict with regular C declarations.

The \emph{type-parameters} is a list of optional C type parameters
for this interface definition:
\begin{quote} \grammarshift
\em \begin{tabbing}
\grammarindent
type-parameters:\\
\>\kw{<} type-parameter-list \kw{>}\\
\\
type-parameter-list:\\
\>identifier\\
\>type-parameter-list \kw{,} identifier
\end{tabbing}
\end{quote}
These parameters belong to the object name space of the interface's
parameter scope (Section~\ref{sec:scoping}) and are therefore visible in
the \emph{declaration-list}. See Section~\ref{sec:type-parameters} for how
type parameters interact with C's type system (in brief, these type
parameters can be used like \kw{typedef}'d types). An interface definition
with type parameters is called a \emph{generic interface definition}.

The \emph{declaration-list} of an interface definition specifies a set of
commands and events. It must consist of function declarations with the
\kw{command} or \kw{event} storage class:
\begin{quote} \grammarshift
\em \begin{tabbing}
\grammarindent
storage-class-specifier: \emph{also one of}\\
\>	\kw{command} \kw{event} \kw{async}\\
\end{tabbing}
\end{quote}
The optional \kw{async} keyword indicates that the command or event can be
executed in an interrupt handler (see Section~\ref{sec:concurrency}). These
functions belong to the object name space of the interface's scope
(Section~\ref{sec:scoping}).


The example code above showed two simple interface definitions
(\code{SendMsg} and \code{Init}). The following
\begin{quote} \begin{verbatim}
interface Queue<t> { 
  async command void push(t x);
  async command t pop();
  async command bool empty();
  async command bool full();
}
\end{verbatim} \end{quote}
defines a generic interface \code{Queue} with a single type parameter,
defining four commands which can be executed in an interrupt handler.

\subsection{Interface Types}

An interface type is specified by giving the name of an interface 
definition and, for generic interface definitions, any required type
arguments:
\begin{quote} \grammarshift
\em \begin{tabbing}
\grammarindent
interface-type: \\
\>	\kw{interface} identifier type-arguments\opt\\
\\
type-arguments:\\
\>	\kw{<} type-argument-list \kw{>}\\
\\
type-argument-list:\\
\>	type-name\\
\>	type-argument-list \kw{,} type-name
\end{tabbing} \end{quote}
There must be as many types in \emph{type-arguments} as there are
parameters in the interface definition's type parameter list.
Type arguments can not be incomplete or of function or array type.

Two interface types are the same if they refer to the same interface
definition and their corresponding type arguments (if any) are of the same
C type. Example interface types are \kw{interface SendMsg} and
\kw{interface Queue<int>}.

\subsection{Component Specification}
\label{sec:component-spec}

A component's specification is a declaration of provided or used
specification elements, where each element is an interface (or,
Section~\ref{sec:bare}, a bare command or event):
\begin{quote} \grammarshift \em \begin{tabbing}
\grammarindent
component-specification:\\
\>	\kw{\{} uses-provides-list \kw{\}}\\
\\
uses-provides-list:\\
\>	uses-provides\\
\>	uses-provides-list uses-provides\\
\\
uses-provides:\\
\>	\kw{uses} specification-element-list\\
\>	\kw{provides} specification-element-list\\
\\
specification-element-list:\\
\>	specification-element\\
\>	\kw{\{} specification-elements \kw{\}}\\
\\
specification-elements:\\
\>	specification-element\\
\>	specification-elements specification-element\\
\end{tabbing} \end{quote}
There can be multiple \kw{uses} and \kw{provides} directives in a component
specification. Multiple used or provided specification elements can be
grouped in a single directive by surrounding them with \{ and \}. For
instance, these two specifications are identical:

\begin{quote} \begin{verbatim}
module A1 {                          module A1 {      
  uses interface X;                    uses {         
  uses interface Y;                      interface X; 
} ...                                    interface Y; 
                                       }              
                                     } ...            
\end{verbatim} \end{quote}

An interface declaration has an interface type and an optional name:
\begin{quote} \grammarshift \em \begin{tabbing}
\grammarindent
specification-element:\\
\>	interface-type instance-name\opt instance-parameters\opt\\
\>	\ldots\\
\\
instance-name:\\
\>	\kw{as} identifier\\
\\
instance-parameters:\\
\>	\kw{[} parameter-type-list \kw{]}
\end{tabbing} \end{quote}
If the name is omitted, the interface's name is the same as the name of the
interface definition specified by the interface type: \code{interface
SendMsg} means the same thing as \code{interface SendMsg as SendMsg} and
\code{interface Queue<int>} is the same as \code{interface Queue<int> as
Queue}. Note that a specification can contain independent interfaces of the
same interface type, e.g., 
\begin{quote}
  \begin{verbatim}
provides interface X as X1; 
uses interface X as X2;
  \end{verbatim}
\end{quote}
The interface names belong to the object name space of the specification's
scope (Section~\ref{sec:scoping}).

An interface declaration without \emph{instance-parameters} (e.g.,
\code{interface X as Y}) declares a \emph{simple interface} to this
component. A declaration with \emph{instance-parameters} (e.g.,
\code{interface SendMsg S[uint8\_t id]}) declares a \emph{parameterised
interface}, corresponding to multiple interfaces to this component, one for
each distinct tuple of parameter values (so \code{interface SendMsg as
S[uint8\_t id, uint8\_t id2]} declares 256 * 256 interfaces of type
\code{SendMsg}). The types of the \emph{parameters} must be integral types
(\kw{enum}s are not allowed at this time).

Here is a full specification example:
\begin{quote} \begin{verbatim}
module AMStandard {
  provides {
    interface StdControl;
    
    // The interface are parameterised by the active message id
    interface SendMsg[uint8_t id];
    interface ReceiveMsg[uint8_t id];
  }
  uses {
    interface StdControl as RadioControl;
    interface SendMsg as RadioSend;
    interface ReceiveMsg as RadioReceive;

    interface StdControl as SerialControl;
    interface SendMsg as SerialSend;
    interface ReceiveMsg as SerialReceive;
  }
} ...
\end{verbatim} \end{quote}
\code{AMStandard} dispatches messages received from the serial port and the
radio to the application based on the ``active message id'' stored in the
message, and sends messages to the radio or serial port depending on the
selected destination address. To support this, it
\begin{itemize}
\item provides interface \code{StdControl} of type \code{StdControl} 
(initialisation of \code{AMStandard}).
\item provides parameterised interfaces of type \code{SendMsg} and
\code{ReceiveMsg}; these interfaces are named \code{SendMsg} and
\code{ReceiveMsg} respectively (these support dispatching of received
messages and sending of messages with a particular active message id).
\item uses interfaces to control, send and receive messages from the radio
and serial port (to interface with the lower-level components providing
radio and serial port networking).
\end{itemize}

\subsection{Bare Commands and Events}
\label{sec:bare}

Commands or events can be included directly as specification elements by
including a standard C function declaration with
\kw{command} or \kw{event} as its storage class specifier:
\begin{quote} \grammarshift \em \begin{tabbing}
\grammarindent
specification-element:\\
\>	declaration\\
\>	\ldots\\
\\
storage-class-specifier: \emph{also one of}\\
\>	\kw{command} \kw{event} \kw{async}\\
\end{tabbing} \end{quote}
It is a compile-time error if the \emph{declaration} is not a function
declaration with the \kw{command} or \kw{event} storage class. As in
interfaces, \kw{async} indicates that the command or event can be called
from an interrupt handler. These bare command and events also belong to the
object name space of the specification's scope (Section~\ref{sec:scoping}).

As with interface declarations, commands (events) can have instance
parameters; these are placed before
the function's regular parameter list, e.g., \code{command void
send[uint8\_t id](int x)}: 
\begin{quote} \grammarshift \em \begin{tabbing}
\grammarindent
direct-declarator: \emph{also}\\
\>	direct-declarator interface-parameters \kw{(} parameter-type-list \kw{)}\\
\>	\ldots
\end{tabbing} \end{quote}

Commands are \emph{simple commands} (\emph{simple events}) if they have no
instance parameters, or \emph{parameterised commands} (\emph{parameterised
events}) if instance parameters are specified. Note that instance
parameters are only allowed on commands or events within component
specifications, not within interface definitions.

\subsection{Command and Event Terminology}

We say that a command (event) $F$ provided in the specification of
component $K$ is \emph{provided command (event)} $F$ of $K$; similarly, a
command (event) used in the specification of component $K$ is \emph{used
command (event)} $F$ of $K$.

A command $F$ in a provided interface $X$ of component $K$ is
provided command $X.F$ of $K$; a command $F$ in a used interface
$X$ of $K$ is used command $X.F$ of $K$; an event $F$ in a provided
interface $X$ of $K$ is used event $X.F$ of $K$; and an event $F$
in a used interface $X$ of $K$ is provided event $X.F$ of $K$
(note the reversal of used and provided for events due to the bidirectional
nature of interfaces). 

We use greek letters $\alpha, \beta, \ldots$ to refer to any command or
event of a component when the distinction between bare commands (events)
and commands (events) in interfaces is not relevant.

We will often simply refer to the ``command or event $\alpha$ of $K$'' when
the used/provided distinction is not relevant.  Commands or events $\alpha$
of $K$ may be parameterised or simple, depending on the parameterised or
simple status of the specification element to which they correspond.

\section{Component Definition}

A \nesc component definition has a name, optional arguments, a
specification and an implementation:
\begin{quote} \grammarshift \em \begin{tabbing}
\grammarindent
component:\\
\>	comp-kind identifier comp-parameters\opt component-specification implementation\\
\\
comp-kind:
\>	\kw{module}\\
\>	\kw{configuration}\\
\>	\kw{generic module}\\
\>	\kw{generic configuration}\\
\\
implementation:\\
\>	module-implementation\\
\>	configuration-implementation
\end{tabbing} \end{quote}

The component name belongs to the component name space of the global scope,
hence must be distinct from other components and from interface
definitions. There are two kinds of components: \emph{modules} are
components which are implemented with C code (Section~\ref{sec:module}),
\emph{configurations} are components which are implemented by assembling
other components (Section~\ref{sec:configuration}). Components with
parameters are called \emph{generic components}, they must be instantiated
in a configuration before they can be used
(Section~\ref{sec:configuration}). Components without parameters exist as a
single instance which is implicitly instantiated. The component's
definition must reflect these distinctions (the \emph{comp-kind} rule): for
instance, a generic module \code{A} is defined with \code{generic module
A() \{}\ldots, a non-generic configuration \code{B} is defined with
\code{configuration B \{}\ldots

\subsection{Generic Components}
\label{sec:generic-components}

Generic component parameter lists are similar to function parameter lists,
but allow for type parameters by (re)using the \kw{typedef} keyword:
\begin{quote} \grammarshift \em \begin{tabbing}
\grammarindent
comp-parameters:\\
\>	\kw{(} component-parameter-list \kw{)}\\
\\
component-parameter-list:\\
\>	component-parameter\\
\>	component-parameter-list \kw{,} component-parameter\\
\\
component-parameter:\\
\>	parameter-declaration\\
\>	\kw{typedef} identifier
\end{tabbing} \end{quote}
The parameters belong to the object name space of the component's parameter
scope (Section~\ref{sec:scoping}), and are hence visible both in the
component's specification and implementation. Non-type parameters must be
of arithmetic or \code{char[]} type. These parameters can be used as
follows:
\begin{itemize}
\item Type parameters can be used as if the argument was of some unknown
\kw{typedef}'d type (for more details, see Section~\ref{sec:type-parameters}).
\item Non-type parameters are constants of some unknown value (for more
details, see Section~\ref{sec:constant-folding}); they can be used in any
constant expression. They cannot be assigned to.
\end{itemize}

An instantiation with arguments $a_1, \ldots, a_n$ of generic component $X$
with parameters $p_1, \ldots, p_n$ behaves like a new, non-generic component
with the specification and implementation of $X$ where all uses of
parameter $p_i$ have been replaced by the corresponding $a_i$ value or
type.\footnote{The most straightforward implementation of these semantics
for generic modules is to duplicate $X$'s code. In some cases (e.g., no
arguments to $X$), a \nesc compiler might be able to share code between the
instances of $X$ at some runtime cost.} Section~\ref{sec:load-component}
details when generic components get instantiated.


\subsection{Examples}

Some examples (with simple specifications):
\begin{quote}
  \begin{verbatim}
module A { provides interface X; } ...
generic configuration B() { uses interface Y; } ...
generic module AQueue(int n, typedef t) { provides interface Queue<t>; } ...
  \end{verbatim}
\end{quote}
\code{A} is a simple module, \code{B} a generic configuration with no
arguments but which can be instantiated multiple times, \code{AQueue}
a generic module implementing an \code{n} entry queue with elements of
type \code{t}. Note how \code{AQueue} instantiates the generic interface
\code{Queue} with its type parameter \code{t}.

\section{Modules}
\label{sec:module}

Modules implement a component specification with C code:
\begin{quote} \grammarshift \em \begin{tabbing}
\grammarindent
module-implementation:\\
\>	\kw{implementation} \kw{\{} translation-unit \kw{\}}\\
\end{tabbing} \end{quote}
where \emph{translation-unit} is a list of C declarations and definitions
(see K\&R~\cite[pp234--239]{kandr}). 

The top-level declarations of the module's \emph{translation-unit} belong
to the module's implementation scope (Section~\ref{sec:scoping}). These
declarations have indefinite extent and can be: any standard C declaration
or definition, a task declaration or definition (placed in the object name
space), a commands or event implementation.

\subsection{Implementing the Module's Specification}

The \emph{translation-unit} must implement all provided commands
(events) $\alpha$ of the module (i.e., all directly provided commands and
events, all commands in provided interfaces and all events in used
interfaces). A module can call any of its commands and signal any of its
events.

These command and event implementations are specified with the following C
syntax extensions:
\begin{quote} \grammarshift \em \begin{tabbing}
\grammarindent
storage-class-specifier: \emph{also one of}\\
\>	\kw{command} \kw{event} \kw{async}\\
\\
declaration-specifiers: \emph{also}\\
\>	\kw{default} declaration-specifiers\\
\\
direct-declarator: \emph{also}\\
\>	identifier \kw{.} identifier \\
\>	direct-declarator interface-parameters \kw{(} parameter-type-list \kw{)}\\
\end{tabbing} \end{quote}
The implementation of simple command or event $\alpha$ has the syntax of a
C function definition for $\alpha$ (note the extension to
\emph{direct-declarator} to allow \code{.} in function names) with storage
class \kw{command} or \kw{event}. Additionally, the \kw{async} keyword must
be included iff it was included in $\alpha$'s declaration. For example, in
a module that provides interface \code{Send} of type \kw{SendMsg}:
\begin{quote} \begin{verbatim}
command result_t Send.send(uint16_t address, uint8_t length, TOS_MsgPtr msg) {
  ...
  return SUCCESS;
}
\end{verbatim} \end{quote}

The implementation of parameterised command or event $\alpha$ with interface
parameters $P$ has the syntax of a C function definition for $\alpha$ with
storage class \kw{command} or \kw{event} where the function's regular
parameter list is prefixed with the parameters $P$ within square brackets
(this is the same syntax as parameterised command or event declarations
within a component specification). These interface parameter declarations
$P$ belong to $\alpha$'s function-parameter scope and have the same extent
as regular function parameters. For example, in a module that provides
interface \code{Send[uint8\_t id]} of type \kw{SendMsg}:
\begin{quote} \begin{verbatim}
command result_t Send.send[uint8_t id](uint16_t address, uint8_t length, 
                                       TOS_MsgPtr msg) {
  ...
  return SUCCESS;
}
\end{verbatim} \end{quote}

Compile-time errors are reported when:
\begin{itemize}
\item There is no implementation for a provided command or event.
\item The type signature, optional interface parameters and presence or
absence of the \kw{async} keyword of a command or event does not match that
given in the module's specification.
\end{itemize}

\subsection{Calling Commands and Signaling Events}

The following extensions to C syntax are used to call events and signal
commands:
\begin{quote} \grammarshift \em \begin{tabbing}
\grammarindent
postfix-expression:\\
\>	postfix-expression \kw{[} argument-expression-list \kw{]}\\
\>	call-kind\opt primary \kw{(} argument-expression-list\opt \kw{)}\\
\>	\ldots
\\\\
call-kind: \emph{one of}\\
\>	\kw{call} \kw{signal} \kw{post}
\end{tabbing} \end{quote}

A simple command $\alpha$ is called with \code{call $\alpha$(...)}, a
simple event $\alpha$ is signaled with \code{signal $\alpha$(...)}. For
instance, in a module that uses interface \code{Send} of type \kw{SendMsg}:
\code{call Send.send(1, sizeof(Message), \&msg1)}.

A parameterised command $\alpha$ (respectively, an event) with $n$
interface parameters of type $\tau_1, \ldots, \tau_n$ is called with
interface parameters expressions $e_1, \ldots, e_n$ as follows: \code{call
$\alpha$[$e_1, \ldots, e_n$](...)}  (respectively, \code{signal
$\alpha$[$e_1, \ldots, e_n$](...)}). Interface parameter expression $e_i$
must be assignable to type $\tau_i$; the actual interface parameter value
is $e_i$ cast to type $\tau_i$. For instance, in a module that uses
interface \code{Send[uint8\_t id]} of type \kw{SendMsg}:

\begin{quote} \begin{verbatim}
  int x = ...;
  call Send.send[x + 1](1, sizeof(Message), &msg1);
\end{verbatim} \end{quote}

Execution of commands and events is immediate, i.e., \kw{call} and
\kw{signal} behave similarly to function calls. The actual command or event
implementations executed by a \code{call} or \code{signal} expression
depend on the wiring statements in the program's configurations. These
wiring statements may specify that 0, 1 or more implementations are to be
executed. When more than 1 implementation is executed, we say that the
module's command or event has ``fan-out''.  

A module can specify a default implementation for a used command or event
$\alpha$ that it calls or signals. A compile-time error occurs for default
implementations of provided commands or events. Default implementations are
executed when $\alpha$ is not connected to any command or event
implementation. A default command or event is defined by prefixing a
command or event implementation with the \kw{default} keyword:
\begin{quote} \grammarshift \em \begin{tabbing}
\grammarindent
declaration-specifiers: \emph{also}\\
\>	\kw{default} declaration-specifiers\\
\end{tabbing} \end{quote}
For instance, in a in a module that uses interface \code{Send} of type
\kw{SendMsg}:
\begin{quote} \begin{verbatim}
default command result_t Send.send(uint16_t address, uint8_t length, 
                                   TOS_MsgPtr msg) {
  return SUCCESS;
}
/* call is allowed even if interface Send is not connected */
... call Send.send(1, sizeof(Message), &msg1) ...
\end{verbatim} \end{quote}

Section~\ref{sec:wiring-semantics} specifies what command or event
implementations are actually executed and what result gets returned by
\code{call} and \code{signal} expressions.

\subsection{Tasks}

A task is an independent locus of control defined by a function of
storage class \kw{task} returning \kw{void} and with no arguments:
\code{task void myTask() \{ ... \}}.\footnote{\nesc functions with no
arguments are declared with \code{()}, not \code{(void)}. See
Section~\ref{sec:misc-void}.} A task can also have a forward declaration, e.g.,
\code{task void myTask();}.

Tasks are posted by prefixing a call to the task with \kw{post}, e.g.,
\code{post myTask()}. Post returns immediately; its return value is 1 if
the task was successfully posted for independent execution, 0
otherwise. The type of a post expression is \code{unsigned char}.
\begin{quote} \grammarshift \em \begin{tabbing}
\grammarindent
storage-class-specifier: \emph{also one of}\\
\>	\kw{task}\\
\\
call-kind: \emph{also one of}\\
\>	\kw{post}
\end{tabbing} \end{quote}

\nesc's concurrency model, including tasks, is presented in detail in
Section~\ref{sec:concurrency}.

\subsection{Atomic statements}

Atomic statements:
\begin{quote} \grammarshift \em \begin{tabbing}
\grammarindent
atomic-stmt: \\
\>	\kw{atomic} statement\\
\end{tabbing} \end{quote}
guarantee that the statement is executed ``as-if'' no other computation
occured simultaneously. It is used to implement mutual exclusion, for
updates to concurrent data structures, etc. A simple example is:
\begin{verbatim}
  bool busy; // global

  void f() {
    bool available;

    atomic {
      available = !busy;
      busy = TRUE;
    }
    if (available) do_something;
    atomic busy = FALSE;
  }
\end{verbatim}

Atomic sections should be short, though this is not currently enforced in
any way.  Control may only flow ``normally'' in or out of on atomic
statement: any \kw{goto}, \kw{break} or \kw{continue} that jumps in or out
of an atomic statement is an error. A \kw{return} statement is never
allowed inside an atomic statement.

Section~\ref{sec:concurrency} discusses the relation between \kw{atomic} and
\nesc's concurrency model and data-race detector.

\section{Configurations}
\label{sec:configuration}

Configurations implement a component specification by selecting regular
components or instantiating generic components, and then connecting
(``wiring'') these components together. The implementation section of
a configuration has two parts:
\begin{quote} \grammarshift \em \begin{tabbing}
\grammarindent
configuration-implementation:\\
\>	\kw{implementation} \kw{\{} component-list\opt connection-list \kw{\}}\\
\end{tabbing} \end{quote}
The \emph{component-list} lists the components that are used to build this
configuration, the \emph{connection-list} specifies how these components
are wired to each other and to the configuration's specification.

In the rest of this section, we call specification elements from the
configuration's specification \emph{external},
and specification elements from one of the configuration's components
\emph{internal}.

\subsection{Included components}
\label{sec:config-components}

The \emph{component-list} specifies the components used to build this
configuration. These can be:
\begin{itemize}
\item A non-generic component $X$. Non-generic components are implicitly
instantiated, references to $X$ in different configurations will all
refer to the same component.

\item An instantiation of a generic component $Y$. Instantiations of $Y$ in
different configurations, or multiple instantiations in the same
configuration will represent different components (see
Section~\ref{sec:generic-components}).
\end{itemize}

This \emph{component-list} has the following syntax:
\begin{quote} \grammarshift \em \begin{tabbing}
\grammarindent
component-list:\\
\>	components\\
\>	component-list components\\
\\
components:\\
\>	\kw{components} component-line \kw{;}\\
\\
component-line:\\
\>	component-ref instance-name\opt\\
\>	component-line \kw{,} component-ref instance-name\opt\\
\\
instance-name:\\
\>	\kw{as} identifier\\
\\
component-ref:\\
\>	identifier\\
\>	\kw{new} identifier \kw{(} component-argument-list \kw{)}\\
\\
component-argument-list:\\
\>	component-argument\\
\>	component-argument-list \kw{,} component-argument\\
\\
component-argument:\\
\>	expression\\
\>	type-name
\end{tabbing} \end{quote}
Each \emph{component-ref} specifies a non-generic component $X$ by simply
giving its name (a compile-time error occurs if $X$ is generic) and
a generic component $Y$ with $\kw{new} Y(args)$ (a compile-time error occurs
if $Y$ is not generic). The arguments to $Y$ must match the number of
parameters $Y$ expects, and:
\begin{itemize}
\item If the parameter is a type parameter, then the argument must be
a non-function, non-array, non-incomplete type.
\item If the parameter is of type \code{char[]}, the argument must be
a string constant.
\item If the parameter is of arithmetic type, the argument must be a 
constant whose value is in the range of the parameter type.
\end{itemize}

Within the \emph{connection-list}, a component specified in the 
\emph{component-list} is referred to by:
\begin{itemize}
\item The name explicitly specified by the \code{X as Y} syntax
(\emph{instance-name}). This is necessary, e.g., when instantiating the
same generic component more than once in a given configuration.
\item The name of the component definition (\code{components new X(), Y;} is
the same as \code{components new X() as X, Y as Y;}).
\end{itemize}
The names specified by the \emph{connection-list} belong to the object name
space of the component's implementation scope (Section~\ref{sec:scoping}).

\subsection{Wiring}
\label{sec:wiring}

Wiring is used to connect specification elements (interfaces, commands,
events) together. This section and the next (Section~\ref{sec:implicit})
define the syntax and compile-time rules for
wiring. Section~\ref{sec:wiring-semantics} details how a program's wiring
statements dictate which functions get called at each \kw{call} and
\kw{signal} expression.  \begin{quote} \grammarshift \em \begin{tabbing}
\grammarindent
connection-list:\\
\>	connection\\
\>	connection-list connection\\
\\
connection:\\
\>	endpoint \kw{=} endpoint\\
\>	endpoint \kw{->} endpoint\\
\>	endpoint \kw{<-} endpoint\\
\\
endpoint:\\
\>	identifier-path \\
\>	identifier-path \kw{[} argument-expression-list \kw{]}\\
\\
identifier-path:\\
\>	identifier\\
\>	identifier-path \kw{.} identifier\\
\end{tabbing} \end{quote}


Wiring statements connect two \emph{endpoints}. The \emph{identifier-path}
of an \emph{endpoint} specifies a specification element. The
\emph{argument-expression-list} optionally specifies interface parameter
values. We say that an endpoint is parameterised if its specification
element is parameterised and the endpoint has no parameter values. A
compile-time error occurs if an endpoint has parameter values and any of
the following is true:
\begin{itemize}
\item The parameter values are not all constant expressions.
\item The endpoint's specification element is not parameterised.
\item There are more (or less) parameter values than there are parameters
on the specification element.
\item The parameter values are not in range for the specification element's
parameter types.
\end{itemize}

A compile-time error occurs if the \emph{identifier-path} of an
\emph{endpoint} is not of one the three following forms:
\begin{itemize}
\item $X$, where $X$ names an external specification element.
\item $K.X$ where $K$ is a component from the \emph{component-list} and
$X$ is a specification element of $K$.
\item $K$ where $K$ is a some component name from the
\emph{component-list}.  This form is used in implicit connections,
discussed in Section~\ref{sec:implicit}. This form cannot be used when
parameter values are specified.

Note that a component name can hide a specification element, preventing
the element from being wired:
\begin{quote}
\begin{verbatim}
configuration AA { provides interface X as Y; }
implementation {
  components Z as Y, Z2 as Y2;

  Y /* refers to component Z, not interface X */ -> Y2.A;
}
\end{verbatim}
\end{quote}
Hiding specification elements will always result in a compile-time error as
specification elements must all be wired.
\end{itemize}

There are three wiring statements in \nesc:
\begin{itemize}
\item \emph{endpoint}$_1$ \code{=} \emph{endpoint}$_2$ \ (equate wires):
Any connection involving an external specification element. These
effectively make two specification elements equivalent.

Let $S_1$ be the specification element of \emph{endpoint}$_1$ and $S_2$
that of \emph{endpoint}$_2$. One of the following two conditions must hold
or a compile-time error occurs:
\begin{itemize}
\item $S_1$ is internal, $S_2$ is external (or vice-versa) and $S_1$ and
$S_2$ are both provided or both used,
\item $S_1$ and $S_2$ are both external and one is provided and the other used.
\end{itemize}

\item \emph{endpoint}$_1$ \code{->} \emph{endpoint}$_2$ \ (link wires): A
connection involving two internal specification elements. Link wires always
connect a used specification element specified by \emph{endpoint}$_1$ to a
provided one specified by \emph{endpoint}$_2$ . If these two conditions do
not hold, a compile-time error occurs.

\item \emph{endpoint}$_1$ \code{<-} \emph{endpoint}$_2$ is equivalent to
\emph{endpoint}$_2$ \code{->} \emph{endpoint}$_1$.
\end{itemize}

In all three kinds of wiring, the two specification elements specified must
be compatible, i.e., they must both be commands, or both be events, or both
be interface instances. Also, if they are commands (or events), then they
must both have the same function signature. If they are interface instances
they must be of the same interface type. If these conditions do not hold,
a compile-time error occurs.

If one endpoint is parameterised, the other must be too and must have the
same parameter types; otherwise a compile-time error occurs.

The same specification element may be connected multiple times, e.g.,:
\begin{quote} \begin{verbatim}
configuration C {
  provides interface X;
} implementation {
  components C1, C2;

  X = C1.X;
  X = C2.X;
}
\end{verbatim} \end{quote}
In this example, the multiple wiring will lead to multiple signalers
(``fan-in'') for the events in interface \code{X} and for multiple
functions being executed (``fan-out'') when commands in interface \code{X}
are called. Note that multiple wiring can also happen when two
configurations independently wire the same interface, e.g.:
\begin{quote} \begin{verbatim}
configuration C { }           configuration D { }
implementation {              implementation {
  components C1, C2;            components C3, C2;

  C1.Y -> C2.Y;                 C3.Y -> C2.Y;
}                             }
\end{verbatim} \end{quote}

All external specification elements must be wired or a compile-time error
occurs. However, internal specification elements may be left unconnected
(these may be wired in another configuration, or they may be left unwired
if the modules have the appropriate \kw{default} event or command
implementations).

\subsection{Implicit Connections}
\label{sec:implicit}

It is possible to write \code{$K_1$ <- $K_2$.$X$} or \code{$K_1$.$X$ <-
$K_2$} (and the same with \kw{=}, or \kw{->}). This syntax iterates through
the specification elements of $K_1$ (resp. $K_2$) to find a specification
element $Y$ such that \code{$K_1$.$Y$ <- $K_2$.$X$} (resp. \code{$K_1$.$X$
<- $K_2$.$Y$}) forms a valid connection. If exactly one such $Y$ can
be found, then the connection is made, otherwise a compile-time error
occurs.

For instance, with:
\begin{quote} \begin{verbatim}
module M1 {                              module M2 {
  provides interface StdControl;           uses interface StdControl as SC;
} ...                                    } ...

              configuration C { }
              implementation {
                components M1, M2;
                M2.SC -> M1;
              }
\end{verbatim} \end{quote}
The \code{M2.SC -> M1} line is equivalent to \code{M2.SC -> M1.StdControl}.

\subsection{Wiring Semantics}
\label{sec:wiring-semantics}

We first explain the semantics of wiring in the absence of parameterised
interfaces. Section~\ref{sec:wiring-parms} below covers parameterised
interfaces. Finally, Section~\ref{sec:wiring-reqs} specifies requirements
on the wiring statements of an application when viewed as a whole. We will
use the simple application of Figure~\ref{fig:wiring} as our running
example.

For the purposes of this section, we will assume that all instantiations of
generic components have been expanded into non-generic components as
explained in Sections~\ref{sec:generic-components}
and~\ref{sec:load-component}.

\begin{figure}
\begin{verbatim}
interface X {               module M {
  command int f();            provides interface X as P;
  event void g(int x);        uses interface X as U;
}                             provides command void h();
                            } implementation { ... }
configuration C {
  provides interface X;
  provides command void h2();
}
implementation {
  components M;
  X = M.P;
  M.U -> M.P;
  h2 = M.h;
}  
\end{verbatim}
\caption{Simple Wiring Example}
\label{fig:wiring}
\end{figure}

We define the meaning of wiring in terms of \emph{intermediate
functions}.\footnote{\nesc can be compiled without explicit intermediate
functions, so the behaviour described in this section has no runtime cost
beyond the actual function calls and the runtime dispatch necessary for
parameterised commands or events.}  There is one intermediate function
$I_\alpha$ for every command or event $\alpha$ of every component. For
instance, in Figure~\ref{fig:wiring}, module M has intermediate functions
$I_\code{M.P.f}$, $I_\code{M.P.g}$, $I_\code{M.U.f}$, $I_\code{M.U.g}$,
$I_\code{M.h}$.  In examples, we name intermediate functions based on their
component, optional interface instance name and function name.

An intermediate function is either used or provided. Each intermediate
function takes the same arguments as the corresponding command or event in
the component's specification. The body of an intermediate function $I$ is
a list of calls (executed sequentially) to other intermediate
functions. These other intermediate functions are the functions to which
$I$ is connected by the application's wiring statements. The arguments $I$
receives are passed on to the called intermediate functions unchanged. The
result of $I$ is a list of results (the type of list elements is the result
type of the command or event corresponding to $I$), built by concatenating
the result lists of the called intermediate functions. An intermediate
function which returns an empty result list corresponds to an unconnected
command or event; an intermediate function which returns a list of two or
more elements corresponds to ``fan-out''.

\paragraph{Intermediate Functions and Configurations}

The wiring statements in a configuration specify the body of intermediate
functions. We first expand the wiring statements to refer to intermediate
functions rather than specification elements, and we suppress the
distinction between \code{=} and \code{->} wiring statements. We write
\code{$I_1$ <-> $I_2$} for a connection between intermediate functions
\code{$I_1$} and \code{$I_2$}. For instance, configuration \code{C} from
Figure~\ref{fig:wiring} specifies the following intermediate function
connections:\\
\begin{tabular}{ccc}
$I_\code{C.X.f}$ \code{<->} $I_\code{M.P.f}$ & 
$I_\code{M.U.f}$ \code{<->} $I_\code{M.P.f}$ & 
$I_\code{C.h2}$ \code{<->} $I_\code{M.h}$ \\
$I_\code{C.X.g}$ \code{<->} $I_\code{M.P.g}$ & 
$I_\code{M.U.g}$ \code{<->} $I_\code{M.P.g}$
\end{tabular}

In a connection \code{$I_1$ <-> $I_2$} from a configuration
$C$ one of the two intermediate functions is the \emph{callee} and the
other is the \emph{caller}. The connection simply specifies that a call to
the callee is added to the body of the caller. \code{$I_1$}
(similarly, \code{$I_2$}) is a callee if any of the following conditions hold
(we use the internal, external terminology for specification elements with
respect to the configuration $C$ containing the connection):
\begin{itemize}
\item If \code{$I_1$} corresponds to an internal specification element that
is a provided command or event.
\item If \code{$I_1$} corresponds to an external specification element that
is a used command or event.
\item If \code{$I_1$} corresponds to a command of interface instance $X$,
and $X$ is an internal, provided or external, used specification element.
\item If \code{$I_1$} corresponds to an event of interface instance $X$,
and $X$ is an external, provided or internal, used specification element.
\end{itemize}
If none of these conditions hold, \code{$I_1$} is a caller. The rules for
wiring in Section~\ref{sec:wiring} ensure that a connection \code{$I_1$ <->
$I_2$} cannot connect two callers or two callees. In configuration \code{C}
from Figure~\ref{fig:wiring}, $I_\code{C.X.f}$, $I_\code{C.h2}$,
$I_\code{M.P.g}$, $I_\code{M.U.f}$ are callers and $I_\code{C.X.g}$,
$I_\code{M.P.f}$, $I_\code{M.U.g}$, $I_\code{M.h}$ are callees. Thus the
connections of \code{C} specify that a call to $I_\code{M.P.f}$ is added to
$I_\code{C.X.f}$, a call to $I_\code{C.X.g}$ is added to $I_\code{M.P.g}$,
etc.


\paragraph{Intermediate Functions and Modules}

The C code in modules calls, and is called by, intermediate functions. 

The intermediate function $I$ for provided command or event $\alpha$ of
module $M$ contains a single call to the implementation of $\alpha$ in
$M$. Its result is the singleton list of this call's result.

The expression \code{call} $\alpha(e_1, \ldots, e_n)$ is evaluated as
follows:
\begin{itemize}
\item The arguments $e_1, \ldots, e_n$ are evaluated, giving values $v_1,
\ldots, v_n$.

\item The intermediate function $I$ corresponding to $\alpha$ is called
with arguments $v_1, \ldots, v_n$, with results list $L$.

\item If $L = (w)$ (a singleton list), the result of the \code{call}
is $w$.

\item If $L = (w_1, w_2, \ldots, w_m)$ (two or more elements), the result
of the \code{call} depends on the result type $\tau$ of $\alpha$. If $\tau
= \kw{void}$, then the result is \kw{void}. Otherwise, $\tau$ must have an
associated \emph{combining function} $c$ (Section~\ref{sec:attributes}
shows how combining functions are assocated with types), or a compile-time
error occurs. The combining function takes two values of type $\tau$ and
returns a result of type $\tau$. The result of the \kw{call} is $c(w_1,
c(w_2, \ldots, c(w_{m-1}, w_m)))$ (note that the order of the elements of 
$L$ was arbitrary).

\item If $L$ is empty the default implementation for $\alpha$ is
called with arguments $v_1, \ldots, v_n$, and its result is the result of
the \code{call}. Section~\ref{sec:wiring-reqs} specifies that a
compile-time error occurs if $L$ can be empty and there is no default
implementation for $\alpha$.
\end{itemize}
The rules for \code{signal} expressions are identical.

\paragraph{Example Intermediate Functions} 

Figure~\ref{fig:wiring-fns} shows the intermediate functions that are
produced for the components of Figure~\ref{fig:wiring}, using a C-like
syntax, where \code{list($x$)} produces a singleton list containing $x$,
\code{empty\_list} is a constant for the 0 element list and
\code{concat\_list} concatenates two lists. The calls to \code{M.P.f},
\code{M.U.g}, \code{M.h} represent calls to the command and event
implementations in module \code{M} (not shown).

\begin{figure}
\begin{tabular}{ll}
\tt list of int $I_\code{M.P.f}()$ \{ & \tt list of void $I_\code{M.P.g}$(int x) \{ \\
\tt \ \ return list(M.P.f());         & \tt \ \ list of int r1 = $I_\code{C.X.g}$(x); \\
\tt \}                                & \tt \ \ list of int r1 = $I_\code{M.U.g}$(x); \\
                                      & \tt \ \ return list\_concat(r1, r2); \\
                                      & \tt \} \\
\\
\tt list of int $I_\code{M.U.f}()$ \{ & \tt list of void $I_\code{M.U.g}$(int x) \{ \\
\tt \ \ return $I_\code{M.P.f}$();    & \tt \ \ return list(M.U.g(x)); \\
\tt \}                                & \tt \} \\
\\
\tt list of int $I_\code{C.X.f}()$ \{ & \tt list of void $I_\code{C.X.g}$(int x) \{ \\
\tt \ \ return $I_\code{M.P.f}$();    & \tt \ \ return empty\_list; \\
\tt \}                                & \tt \} \\
\\
\tt list of void $I_\code{C.h2}()$ \{ & \tt list of void $I_\code{M.h}$() \{ \\
\tt \ \ return $I_\code{M.h}$();      & \tt \ \ return list(M.h()); \\
\tt \}                                & \tt \} \\
\end{tabular}
\caption{Intermediate Functions for Figure~\ref{fig:wiring}}
\label{fig:wiring-fns}
\end{figure}

\subsubsection{Wiring and Parameterised Functions}
\label{sec:wiring-parms}

If a command or event $\alpha$ of component $K$ is parameterised with
interface parameters of type $\tau_1, \ldots, \tau_n$ then there is an
intermediate function $I_{\alpha,v_1,\ldots,v_n}$ for every distinct tuple
$(v_1:\tau_1, \ldots, v_n:\tau_n)$.

In modules, if intermediate function $I_{v_1, \ldots, v_n}$ corresponds
to parameterised, provided command (or event) $\alpha$ then the call in
$I_{v_1, \ldots, v_n}$ to $\alpha$'s implementation passes values $v_1,
\ldots, v_n$ as the values for $\alpha$'s interface parameters. 

The expression \code{call} $\alpha[e'_1, \ldots, e'_m](e_1, \ldots, e_n)$
is evaluated as follows:
\begin{itemize}
\item The arguments $e_1, \ldots, e_n$ are evaluated, giving values $v_1,
\ldots, v_n$.
\item The arguments $e'_1, \ldots, e'_m$ are evaluated, giving values $v'_1,
\ldots, v'_m$.
\item The $v'_i$ values are cast to type $\tau_i$, where $\tau_i$ is the
type of the $i$th interface parameter of $\alpha$.
\item The intermediate function $I_{v'_1,\ldots,v'_m}$ corresponding to
$\alpha$ is called with arguments $v_1, \ldots, v_n$, with results list
$L$.\footnote{This call typically involves a runtime selection between
several command implementations - this is the only place where intermediate
functions have a runtime cost.}
\item If $L$ has one or more elements, the result of the \code{call} is
produced as in the non-parameterised case.
\item If $L$ is empty the default implementation for $\alpha$ is called
with interface parameter values $v'_1, \ldots, v'_m$ and arguments $v_1,
\ldots, v_n$, and its result is the result of the
\code{call}. Section~\ref{sec:wiring-reqs} specifies that a compile-time
error occurs if $L$ can be empty and there is no default implementation for
$\alpha$.
\end{itemize}
The rules for \code{signal} expressions are identical.

There are two cases when an endpoint in a wiring statement refers to a
parameterised specification element:
\begin{itemize}
\item The endpoint specifies parameter values $v_1, \ldots, v_n$. If the
endpoint corresponds to commands or events $\alpha_1, \ldots, \alpha_m$
then the corresponding intermediate functions are
$I_{\alpha_1,v_1,\ldots,v_n}$, \ldots, $I_{\alpha_m,v_1,\ldots,v_n}$ and
wiring behaves as before.
\item The endpoint does not specify parameter values. In this case, both
endpoints in the wiring statement correspond to parameterised specification
elements, with identical interface parameter types $\tau_1, \ldots,
\tau_n$. If one endpoint corresponds to commands or events $\alpha_1,
\ldots, \alpha_m$ and the other to corresponds to commands or events
$\beta_1, \ldots, \beta_m$, then there is a connection $I_{\alpha_i, w_1,
\ldots, w_n}$ \code{<->} $I_{\beta_i, w_1,\ldots, w_n}$ for all $1 \leq i
\leq m$ and all tuples $(w_1:\tau_1, \ldots, w_n:\tau_n)$ (i.e., the
endpoints are connected for all corresponding parameter values).
\end{itemize}

\subsubsection{Application-level Requirements}
\label{sec:wiring-reqs}

There are two requirement that the wiring statements of an application must
satisfy, or a compile-time error occurs:
\begin{itemize}
\item There must be no infinite loop involving only intermediate functions.
\item At every \code{call $\alpha$} (or \code{signal $\alpha$}) expression
in the application's modules:
\begin{itemize}
\item If the call is unparameterised: if the call returns an empty result
list there must be a default implementation of $\alpha$ (the number of
elements in the result list depends only on the wiring).
\item If the call is parameterised: if substituation of any values for the
interface parameters of $\alpha$ returns an empty result list there must be
a default implementation of $\alpha$ (the number of elements in the result
list for a given parameter value tuple depends only on the wiring).

Note that this condition does not consider the expressions used to specify
interface parameter values at the call-site.
\end{itemize}
\end{itemize}

\section{Concurrency in \nesc}
\label{sec:concurrency}

\nesc assumes an execution model that consists of run-to-completion
\emph{tasks} (that typically represent the ongoing computation), and
\emph{interrupt handlers} that are signaled asynchronously by hardware.  A
scheduler for \nesc can execute tasks in any order, but must obey the
run-to-completion rule (the standard \tinyos scheduler follows a FIFO
policy). Because tasks are not preempted and run to completion, they are
atomic with respect to each other, but are not atomic with respect to
interrupt handlers.

As this is a concurrent execution model, \nesc programs are susceptible to
race conditions, in particular data races on the program's \emph{shared
state}, i.e., its global and module variables (\nesc does not include
dynamic memory allocation). Races are avoided either by accessing a
shared state only in tasks, or only within atomic statements. The \nesc
compiler reports potential data races to the programmer at compile-time.

Formally, we divide the code of a \nesc program into two parts:
\begin{quote}
\textbf{Synchronous Code (SC):} code (functions, commands, events, tasks)
that is only reachable from tasks.

\textbf{Asynchronous Code (AC):} code that is reachable from at 
least one interrupt handler.
\end{quote}

Although non-preemption eliminates data races among tasks, there are still
potential races between SC and AC, as well as between AC and AC.  In
general, any update to shared state that is {\em reachable from AC} is a
potential data race.  The basic invariant \nesc enforces is:
\begin{quote}
{\sl {\bf Race-Free Invariant}: Any update to shared state is either
SC-only or occurs in an atomic statement.} The body of a function $f$
called from an atomic statement is considered to be ``in'' the atomic
statement as long as all calls to $f$ are ``in'' atomic statements.
\end{quote}

It is possible to introduce a race condition that the compiler cannot
detect, but it must span multiple atomic statements or tasks and use storage
in intermediate variables.

\nesc may report data races that cannot occur in practice, e.g., if all
accesses are protected by guards on some other variable. To avoid redundant
messages in this case, the programmer can annotate a variable $v$ with the
\kw{norace} storage-class specifier to eliminate all data race warnings for
$v$. The \kw{norace} keyword should be used with caution.

\nesc reports a compile-time error for any command or event that is AC and
that was not declared with \kw{async}. This ensures that code that was not
written to execute safely in an interrupt handler is not called
inadvertently.

\section{\nesc Applications}
\label{sec:app}

A \nesc application has three parts: a list of C declarations and
definitions, a set of interface definitions and a set of components
(non-generic components and instantiated generic components).

The C declarations and defintions, interfaces and components that form
a \nesc application are determined by an on-demand loading process. The
input to the \nesc compiler is a single non-generic component $K$. The
\nesc compiler first loads a user-specified set of C
files\footnote{\kw{ncc}, the TinyOS frontend for \nesc always loads the
TinyOS \file{tos.h} file.} (Section~\ref{sec:load-c}), then loads component
$K$ (Section~\ref{sec:load-component}). The code for the application is all
the C code loaded and all the components generated as a result of loading
these two files. A \nesc compiler can assume that all calls to functions,
commands or events not marked with the \code{spontaneous}, \code{hwevent}
or \code{atomic\_hwevent} attributes (Section~\ref{sec:attributes}) occur
in the loaded code (i.e., there are no ``invisible'' calls to any other
functions).\footnote{For instance, the current \nesc compiler uses this
information to eliminate unreachable code.}

During preprocessing of loaded files, \nesc defines the \kw{NESC} symbol to
a number XYZ which identifies the version of the \nesc language and compiler.
For \nesc 1.1, XYZ is at least 110.\footnote{The \kw{NESC} symbol was not
defined in earlier versions of \nesc.}

Part of the process of loading a C file, \nesc component or interface
definition involves locating the corresponding source file. The mechanism
used to locate files is outside the scope of this reference manual; for
details on how this works in the current compiler please see the \file{ncc}
man page.

\subsection{Loading C file $X$}
\label{sec:load-c}

If $X$ has already been loaded, nothing more is done. Otherwise, file $X$.h
is located and preprocessed. Changes made to C macros (via \code{\#define}
and \code{\#undef}) are visible to all subsequently preprocessed files. The C
declarations and definitions from the preprocessed $X$.h file are entered
into the C global scope, and are therefore visible to all subsequently
processed C files, interfaces and components.

\subsection{Loading Component $K$}
\label{sec:load-component}

If $K$ has already been loaded, nothing more is done. Otherwise, file
$K$.nc is located and preprocessed. Changes made to C macros (via
\code{\#define} and \code{\#undef}) are discarded. The preprocessed file is
parsed using the following grammar: \begin{quote} \grammarshift \em \begin{tabbing}
\grammarindent
nesC-file: \\
\>	includes-list\opt interface\\
\>	includes-list\opt module\\
\>	includes-list\opt configuration\\
\\
includes-list:\\
\>	includes\\
\>	includes-list includes\\
\\
includes:\\
\>	\kw{includes} identifier-list \kw{;}\\
\end{tabbing} \end{quote}
If $K$.nc does not define \code{module $K$} or \code{configuration $K$}, a
compile-time error is reported. Otherwise, all C files specified by the
\emph{includes-list} are loaded (Section~\ref{sec:load-c}possibly). Note that
as file $K$.nc has already been loaded, macros defined in these files cannot
be used in $K$.nc (though they will be visible for subsequently loaded files).

Next, all interface definitions used in the component's specification are
loaded (Section~\ref{sec:load-intf}). Next, the component specification is
processed (Section~\ref{sec:component-spec}). If $K$ is a configuration, all
component definitions used (Section~\ref{sec:config-components}) in $K$ are
loaded (Section~\ref{sec:load-component}). The implementation of $K$ is
then checked according to the rules of Section~\ref{sec:module} or
Section~\ref{sec:configuration}.

Finally, $K$ is processed to produce a set of output components via the
following algorithm:

Expand($K$):
\begin{itemize}
\item If $K$ is a generic component, no component is output.

\item If $K$ is a non-generic module, $K$ is output.

\item If $K$ is a non-generic configuration: for each component
instantiation $\kw{new} L(a_1, \ldots, a_n)$ in $K$, a new component $X$ is
created according to the rules of Section~\ref{sec:generic-components} and
Expand($X$) is called recursively (instantiating further generic components
if $L$ contained component instantiations). Then $K$ is output.
\end{itemize}

\subsection{Loading Interface Definition $I$}
\label{sec:load-intf}

If $I$ has already been loaded, nothing more is done. Otherwise, file
$I$.nc is located and preprocessed. Changes made to C macros (via
\code{\#define} and \code{\#undef}) are discarded. The preprocessed file is
parsed following the \emph{nesC-file} production above. If $I$.nc does not
define \code{interface $I$} a compile-time error is reported. Otherwise,
all C files specified by the \emph{includes-list} are loaded
(Section~\ref{sec:load-c}) (as with components, macros defined in these C
files cannot be used in $I$.nc as it has already been preprocessed). Then
$I$'s definition is processed (Section~\ref{sec:interface}).

As an example of including C files in components or interfaces, interface
definition \code{Bar} might include C file \file{BarTypes.h} which defines types
used in \code{Bar}:

\begin{quote} \begin{verbatim}
Bar.nc:                                        BarTypes.h:      
includes BarTypes;                             typedef struct { 
interface Bar {                                  int x;         
  command result_t bar(BarType arg1);            double y;      
}                                              } BarType;
\end{verbatim} \end{quote}

The definition of interface \code{Bar} can refer to \code{BarType}, as can
any component that uses or provides interface \code{Bar} (interface
\code{Bar}, and hence \file{BarTypes.h}, are loaded before any such
component's specification or implementation are processed).

\section{Miscellaneous}
\label{sec:misc}

\subsection{Constant Folding in \nesc}
\label{sec:constant-folding}

There are two extensions to C's constant folding (see A.7.19 in
\cite{kandr}) in \nesc: \emph{constant functions} and \emph{unknown
constants}. \emph{Constant Functions} are functions provided by the \nesc
language which return a compile-time constant. The definition of \nesc's
constant functions is given in Section~\ref{sec:constant-functions}. An
\emph{unknown constant} is a constant whose value is not yet known, e.g.,
non-type parameters to generic components are unknown constants. Unknown
constants allow the definition of a generic component to be (mostly, see
below) checked for correctness before its arguments' values are known.

An expression involving an unknown constant is considered a constant
expression if the resulting expression is constant irrespective of the
unknown constant's value, with the following exceptions: $a / b$ and $a \%
b$ can assume that $b$ is not zero. Constant expressions involving unknown
constants are re-checked once the values of constant expressions become
known.\footnote{The time at which the value of unknown constants become
known is unspecified by this language definition.} As a result, the
following generic component definition is legal:
\begin{quote}
\begin{verbatim}
generic module A(int n) { }
implementation {
  int s = 20 / n;
}
\end{verbatim}
\end{quote}
but the following instantiation will report a compile-time error:
\begin{quote}
\begin{verbatim}
 configuration B { }
implementation {
  components new A(0) as MyA;
}
\end{verbatim}
\end{quote}

\subsection{Compile-time Constant Functions}
\label{sec:constant-functions}

\nesc currently has two constant functions:
\begin{itemize}
\item 
\code{unsigned int unique(char *identifier)} \\ Returns: each call to
\code{unique} with the same \code{identifier} string returns a different
value. The expansion of \code{unique} calls happens after generic component
instantiation (Section~\ref{sec:load-component}): calls to \code{unique} in
generic components return a different value in each instantiation. The
range of values returned by \code{unique($s$)} is $0 .. n-1$, where $n$ is
the number of different values returned by \code{unique($s$)}. For
purposes of checking constant expressions, \code{unique($s$)} behaves
as if it were an unknown constant.

The intended use of \code{unique} is for passing a unique integer
to parameterised interface instances, so that a component providing
a parameterised interface can uniquely identify the various components
connected to that interface.

\item \code{unsigned int uniqueCount(char *identifier)} \\ Returns:
\code{uniqueCount($s$)} returns one more than the largest value returned by
any of the calls to \code{unique($s$)}, or 0 if there are no calls to
\code{unique($s$)}. For purposes of checking constant expressions,
\code{uniqueCount($s$)} behaves as if it were an unknown constant.

The intended use of \code{uniqueCount} is for dimensioning arrays (or other
data structures) which will be indexed using the numbers returned by
\kw{unique}. For instance, a \kw{Timer} service that identifies its clients
(and hence each independent timer) via a parameterised interface and
\kw{unique} can use \kw{uniqueCount} to allocate the correct number of
timer data structures.

\end{itemize}

In the following example:
\begin{quote}
\begin{verbatim}
generic module A() { }
implementation {
  int x = unique("A");
  int y = uniqueCount("A");
}
configuration B { }
implementation {
  components new A() as A1, new A() as A2;
}
\end{verbatim}
\end{quote}
\code{B.A1.y = B.A2.y = 2} and either \code{B.A1.x = 0, B.A2.x = 1} or
\code{B.A1.x = 1, B.A2.x = 0}.

\subsection{Type Parameters and C Type Checking}
\label{sec:type-parameters}

Generic interface and component definitions can have type
parameters. Syntaxically, type parameters behave the same as \kw{typedef}'d
identifiers. When a generic component or interface is instantiated, the
type parameter will be replaced with the argument type, which cannot be
incomplete, of function or of array type. The size and alignment of a type
parameter are an unknown constant (Section~\ref{sec:constant-folding}).
The rules for assignment and type equivalence for a type parameter $t$ are
simple: a value of type $t$ is assignable to an lvalue of type $t$ (extends
A.7.17 in~\cite{kandr}) and type $t$ is only equivalent to itself (extends
A.8.10 in~\cite{kandr}).


\begin{itemize}
\item To build new 
\end{itemize}

\subsection{Functions with no arguments, old-style C declarations}
\label{sec:misc-void}

\nesc functions with no arguments are declared with \code{()}, not
\code{(void)}. The latter syntax reports a compile-time error.

Old-style C declarations (with \code{()}) and function definitions 
(parameters specified after the argument list) are not allowed in
interfaces or components (and cause compile-time errors).

Note that neither of these changes apply to C files (so that existing
\file{.h} files can be used unchanged).

\subsection{// comments}

\nesc allows // comments in C, interface and component files.

\subsection{Attributes}
\label{sec:attributes}

\nesc uses gcc's\footnote{http://gcc.gnu.org} \kw{\_\_attribute\_\_} syntax
for declaring some properties of functions, variables and typedefs. These
attributes can be placed either on declarations (after the declarator) or
function definitions (after the parameter list).\footnote{gcc doesn't
allow attributes after the parameter list in function definitions.} The
attributes of $x$ are the union of all attributes on all declarations and
definitions of $x$.

The attribute syntax in \nesc is:
\begin{quote} \grammarshift \em \begin{tabbing}
\grammarindent
init-declarator-list: \emph{also}\\
\>	init-declarator attributes\\
\>	init-declarator-list \kw{,} init-declarator attributes\\
\\
function-definition: \emph{also}\\
\>	declaration-specifiers\opt declarator attributes declaration-list\opt compound-statement\\
\\
attributes:\\
\>	attribute\\
\>	attributes attribute\\
\\
attribute:\\
\>	\kw{\_\_attribute\_\_} \kw{(} \kw{(} attribute-list \kw{)} \kw{)}\\
\\
attribute-list:\\
\>	single-attribute\\
\>	attribute-list \kw{,} single-attribute\\
\\
single-attribute:\\
\>	identifier\\
\>	identifier \kw{(} argument-expression-list \kw{)}\\
\end{tabbing} \end{quote}

\nesc supports three attributes:
\begin{itemize}
\item \code{C}: This attribute is used for a C declaration or definition
$d$ at the top-level of a module (it is ignored for all other
declarations). It specifies that $d$'s should appear in the global C scope
rather than in the module's per-component-implementation scope. This allows
$d$ to be used (e.g., called if it is a function) from C code.

\item \code{spontaneous}: This attribute can be used on any function
$f$ (in modules or C code). It indicates that there are calls $f$ that
are not visible in the source code. Typically, functions that are
called spontaneously are interrupt handlers, and the C \code{main}
function. Section~\ref{sec:app} discusses how the \nesc compiler
uses the \code{spontaneous} attribute during compilation.

\item \code{hwevent}: This attribute can be used on any function $f$ (in
modules or C code). It indicates that $f$ is an interrupt handler, i.e.,
that there are spontaneous calls to $f$ and that $f$ is AC
(Section~\ref{sec:concurrency}).

\item \code{atomic\_hwevent}: This attribute can be used on any function
$f$ (in modules or C code). This behaves the same as \code{hwevent}, but,
additionally, informs \nesc that the body of $f$ behaves as if it
were an \kw{atomic} statement (on typical hardware this means that this
interrupt handler runs with interrupts disabled).

Note that neither \code{hwevent} or \code{atomic\_hwevent} provide any
linkage of $f$ with a particular interrupt handler. The mechanism by
which that is achieved is platform-specific.

\item \code{combine($fnname$)}: This attribute specifies the combining
function for a type in a \kw{typedef} declaration. The combining function
specifies how to combine the multiple results of a call to a command
or event which has ``fan-out''. For example:
\begin{verbatim}
  typedef uint8_t result_t __attribute__((combine(rcombine)));

  result_t rcombine(result_t r1, result_t r2)
  {
    return r1 == FAIL ? FAIL : r2;
  }
\end{verbatim}
specifies logical-and-like behaviour when combining commands (or events)
whose result type is \code{result\_t}. See
Section~\ref{sec:wiring-semantics} for the detailed semantics.

A compile-time error occurs if the combining function $c$ for a type $t$
does not have the following type: \code{$t$ $c$($t$, $t$)}.

\end{itemize}

Example of attribute use: in file \file{RealMain.td}:
\begin{quote} \begin{verbatim}
module RealMain { ... }
implementation {
  int main(int argc, char **argv) __attribute__((C, spontaneous)) {
    ...
  }
}
\end{verbatim} \end{quote}

This example declares that function \code{main} should actually appear
in the C global scope (\code{C}), so that the linker can find it. It
also declares that \code{main} can be called even though there are no
function calls to \code{main} anywhere in the program
(\code{spontaneous}). 

\appendix

\section{Grammar}
\label{sec:grammar}

Please refer to  Appendix~A of Kernighan and Ritchie (K\&R)
~\cite[pp234--239]{kandr} while reading this grammar.

The following keywords are new for \nesc: \kw{as}, \kw{call}, \kw{command},
\kw{components}, \kw{configuration}, \kw{event}, \kw{implementation},
\kw{interface}, \kw{module}, \kw{post}, \kw{provides}, \kw{signal},
\kw{task}, \kw{uses}, \kw{includes}. These \nesc keywords are not reserved
in C files. The corresponding C symbols are accessible in \nesc files by
prefixing them with \kw{\_\_nesc\_}\emph{keyword} (e.g.,
\kw{\_\_nesc\_keyword\_as}).

\nesc reserves all identifiers starting with \kw{\_\_nesc} for internal
use. \tinyos reserves all identifiers starting with \kw{TOS\_} and
\kw{TOSH\_}.

\nesc files follow the \emph{nesC-file} production; \file{.h} files included
via the \kw{includes} directive follow the \emph{translation-unit}
directive from K\&R. 

New rules:
\em \begin{tabbing}
\grammarindent
nesC-file: \\
\>	includes-list\opt interface\\
\>	includes-list\opt module\\
\>	includes-list\opt configuration\\
\\
includes-list:\\
\>	includes\\
\>	includes-list includes\\
\\
includes:\\
\>	\kw{includes} identifier-list \kw{;}\\
\\
interface:\\
\>	\kw{interface} identifier \kw{\{} declaration-list \kw{\}}\\
\\
module:\\
\>	\kw{module} identifier specification module-implementation\\
\\
module-implementation:\\
\>	\kw{implementation} \kw{\{} translation-unit \kw{\}}\\
\\
configuration:\\
\>	\kw{configuration} identifier specification configuration-implementation\\
\\
configuration-implementation:\\
\>	\kw{implementation} \kw{\{} component-list\opt connection-list \kw{\}}\\
\\
component-list:\\
\>	components\\
\>	component-list components\\
\\
components:\\
\>	\kw{components} component-line \kw{;}\\
\\
component-line:\\
\>	renamed-identifier\\
\>	component-line \kw{,} renamed-identifier\\
\\
renamed-identifier:\\
\>	identifier\\
\>	identifier \kw{as} identifier\\
\\
connection-list:\\
\>	connection\\
\>	connection-list connection\\
\\
connection:\\
\>	endpoint \kw{=} endpoint\\
\>	endpoint \kw{->} endpoint\\
\>	endpoint \kw{<-} endpoint\\
\\
endpoint:\\
\>	identifier-path \\
\>	identifier-path \kw{[} argument-expression-list \kw{]}\\
\\
identifier-path:\\
\>	identifier\\
\>	identifier-path \kw{.} identifier\\
\\
specification:\\
\>	\kw{\{} uses-provides-list \kw{\}}\\
\\
uses-provides-list:\\
\>	uses-provides\\
\>	uses-provides-list uses-provides\\
\\
uses-provides:\\
\>	\kw{uses} specification-element-list\\
\>	\kw{provides} specification-element-list\\
\\
specification-element-list:\\
\>	specification-element\\
\>	\kw{\{} specification-elements \kw{\}}\\
\\
specification-elements:\\
\>	specification-element\\
\>	specification-elements specification-element\\
\\
specification-element:\\
\>	declaration\\
\>	\kw{interface} renamed-identifier parameters\opt\\
\\
parameters:\\
\>	\kw{[} parameter-type-list \kw{]}
\end{tabbing} \rm

Changed rules: 
\em \begin{tabbing}
\grammarindent
storage-class-specifier: \emph{also one of}\\
\>	\kw{command} \kw{event} \kw{async} \kw{task} \kw{norace}\\
\\
declaration-specifiers: \emph{also}\\
\>	\kw{default} declaration-specifiers\\
\\
direct-declarator: \emph{also}\\
\>	identifier \kw{.} identifier \\
\>	direct-declarator parameters \kw{(} parameter-type-list \kw{)}\\
\\
init-declarator-list: \emph{also}\\
\>	init-declarator attributes\\
\>	init-declarator-list \kw{,} init-declarator attributes\\
\\
function-definition: \emph{also}\\
\>	declaration-specifiers\opt declarator attributes declaration-list\opt compound-statement\\
\\
attributes:\\
\>	attribute\\
\>	attributes attribute\\
\\
attribute:\\
\>	\kw{\_\_attribute\_\_} \kw{(} \kw{(} attribute-list \kw{)} \kw{)}\\
\\
attribute-list:\\
\>	single-attribute\\
\>	attribute-list \kw{,} single-attribute\\
\\
single-attribute:\\
\>	identifier\\
\>	identifier \kw{(} argument-expression-list \kw{)}\\
\\
statement: \emph{also}\\
\>	atomic-statement\\
\\
atomic-statement:\\
\>	\kw{atomic} statement\\
\\
postfix-expression: \emph{replaced by}\\
\>	primary-expression\\
\>	postfix-expression \kw{[} argument-expression-list \kw{]}\\
\>	call-kind\opt primary \kw{(} argument-expression-list\opt \kw{)}\\
\>	postfix-expression \kw{.} identifier\\
\>	postfix-expression \kw{->} identifier\\
\>	postfix-expression \kw{++}\\
\>	postfix-expression \kw{--}\\
\\\\
call-kind: \emph{one of}\\
\>	\kw{call} \kw{signal} \kw{post}
\end{tabbing} \rm

\section{Glossary}
\label{sec:glossary}

\begin{itemize}

\item \emph{combining function}: C function that combines the multiple
results of command call (or event signal) in the presence of
\emph{fan-out}.

\item \emph{command}, \emph{event}: A function that is part of a
component's \emph{specification}, either directly as a \emph{specification
element} or within one of the component's \emph{interface instances}.

When used directly as specification elements, commands and events have
roles (\emph{provider}, \emph{user}) and can have \emph{interface
parameters}. As with interface instances, we distinguish between
\emph{simple commands (events)} without interface parameters and
\emph{parameterised commands (events)} with interface parameters. The
interface parameters of a command or event are distinct from its regular
function parameters.

\item \emph{compile-time error}: An error that the \nesc compiler must
report at compile-time.

\item \emph{component}: The basic unit of \nesc programs. Components have a
name and are of two kinds: \emph{modules} and \emph{configurations}. A
component has a \emph{specification} and an implementation. 

\item \emph{configuration}: A component whose implementation is provided
by a composition of other components with a specific \emph{wiring}.

\item \emph{endpoint}: A specification of a particular specification
element, and optionally some interface parameter values, in a wiring
statement of a configuration. A parameterised endpoint is an endpoint
without parameter values that corresponds to a parameterised specification
element.

\item \emph{event}: See command.

\item \emph{extent}: The lifetime of a variable. \nesc has the standard C
extents: \emph{indefinite}, \emph{function}, and \emph{block}.

\item \emph{external}: In a configuration $C$, describes a specification
element from $C$'s specification. See internal.

\item \emph{fan-in}: Describes a provided command or event called from more
than one place.

\item \emph{fan-out}: Describes a used command or event connected to more
than one command or event implementation. A \emph{combining function}
combines the results of calls to these used commands or events.

\item \emph{interface}: When the context is unambiguous, we use interface
to refer to either an \emph{interface type} or an \emph{interface instance}.

\item \emph{interface instance}: An instance of a particular
\emph{interface type} in the \emph{specification} of a component. An
interface instance has an instance name, a role (\emph{provider} or
\emph{user}), an \emph{interface type} and, optionally, \emph{interface
parameters}. An interface instance without parameters is a \emph{simple
interface instance}, with parameters it is a \emph{parameterised interface
instance}.

\item \emph{interface parameter}: An interface parameter has an interface
parameter name and must be of integral type. 

There is (conceptually) a separate \emph{simple interface instance} for
each distinct list of parameter values of a \emph{parameterised interface
instance} (and, similarly, separate simple commands or events in the case
of parameterised commands or events). Parameterised interface instances
allow runtime selection based on parameter values between a set of commands
(or between a set of events).

\item \emph{interface type}: An \emph{interface type} specifies the
interaction between two components, \emph{the provider} and the
\emph{user}. This specification takes the form of a set of \emph{commands}
and \emph{events}. Each interface type has a distinct name. 

Interfaces are bi-directional: the provider of an interface implements its
commands, the user of an interface implements its events.

\item \emph{intermediate function}: A pseudo-function that represents the
behaviour of the commands and events of a component, as specified by the
wiring statements of the whole application. See
Section~\ref{sec:wiring-semantics}.

\item \emph{internal}: In a configuration $C$, describes a specification
element from one of the components specified in $C$'s component list. See
external.

\item \emph{module}: A component whose implementation is provided by C
code. 

\item \emph{namespace}: \nesc has the standard C \emph{variable} (also
used for functions and \code{typedef}s), \emph{tagged type} (\code{struct},
\code{union} and \code{enum} tag names) and \emph{label}
namespaces. Additionally, \nesc has a \emph{component and interface type}
namespace for component and interface type names.

\emph{parameterised command, parameterised event, parameterised interface
instance, endpoint}: See command, event, interface instance, endpoint.

\emph{provided, provider}: A role for a specification element. Providers of
\emph{interface instances} must implement the \emph{commands} in the
interface; provided commands and events must be implemented.

\emph{provided command of $K$}: A command that is either a
provided specification element of $K$, or a command of a provided interface
of $K$.

\emph{provided event of $K$}: An event that is either a
provided specification element of $K$, or an event of a used interface
of $K$.

\item \emph{scope}: \nesc has the standard C \emph{global},
\emph{function-parameter} and \emph{block} scopes. Additionally there are
\emph{specification} and \emph{implementation} scopes in components and a
per-interface-type scope. Scopes are divided into namespaces.

\emph{simple command, simple event, simple interface instance}: See
command, event, interface instance.

\item \emph{specification}: A list of \emph{specification elements} that
specifies the interaction of a component with other components.

\item \emph{specification element}: An \emph{interface instance},
\emph{command} or \emph{event} in a specification that is either 
\emph{provided} or \emph{used}.

\item \emph{task}: A \tinyos task.

\emph{used, user}: A role for a specification element. Users of
\emph{interface instances} must implement the \emph{events} in the
interface.

\emph{used command of $K$}: A command that is either a used specification
element of $K$, or a command of a used interface of $K$.

\emph{used event of $K$}: An event that is either a used specification
element of $K$, or an event of a provided interface of $K$.

\item \emph{wiring}: The connections between component's specification
elements specified by a configuration.

\end{itemize}


\bibliographystyle{abbrv}
\bibliography{ref}

\end{document}
